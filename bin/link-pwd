#!/bin/bash
#
cmd=$(basename $0)
# linkfile=(" $HOME/.local/man/man1/link-pwd.1   man/man1/man_link-pwd.man" \
# "$HOME/.local/man/man1/link-pwd.1   man/man1/man_link-pwd.man")
################################################################################
# Save is either saving a copy of the link or remembering that there was nothing
# there
################################################################################
save_target(){
    local target=$1

    if [ -e $target ] ; then
        echo "$(tput setaf 2)SAVING $target as $(basename $target).restore$(tput sgr 0)"
        mv $target $(basename $target).restore
    fi
}

################################################################################
# Restore by either deleting or squashing with the saved file
################################################################################
restore_target(){
    local target=$1
    local base_target=$(basename $target)
    local restore_file=$base_target.restore

    if [ -e $restore_file ] ; then
        echo "$(tput setaf 3)RESTORING $target from $restore_file$(tput sgr 0)"
        # Note that the -T option doesn't work on OSX's mv command so I have to
        # remove the link first otherwise, it might move $restore_file
        # into the directory pointed to by $target
        rm -f $target
        mv $restore_file $target
    elif [ -L $target ] ; then
        echo "$(tput setaf 1)DELETING link $target$(tput sgr 0)"
        rm -f $target
    elif [ -e $target ] ; then
        echo "$(tput setaf 1)[[ CANT HAPPEN ]]Target $target exists and is not a link$(tput sgr 0)"
    fi
}

################################################################################
# Create a link for the file if the target exitst in pwd
################################################################################
maybe_link(){
    local target=$1
    local link_name=$2

    if [ -e $target ] ; then
       echo "$(tput setaf 4)LINKING $link_name --> $target$(tput sgr 0)"
       ln -s $target $link_name
    fi
}

unlink_target(){
    local target=$1

    if [ -e $target ] && ! [ -L $target ] ; then
        echo "$cmd : ERROR : unlink_target : target=$target exits and is not a link"
        exit 1
    fi

    if [ -e $target ] ; then
        echo "$(tput setaf 284)DELETING link $target$(tput sgr 0)"
        rm -f $target
    fi
}

save_and_link(){
    local target=$1
    local my_file=$2
    save_target $target $my_file
    maybe_link $my_file $target
}

status()
{
    local target=$1
    local my_file=$2
    local base_target=$(basename $target)
    local restore_file="$base_target.restore"

    if ! [ -z $restore_file ] && [ -e $restore_file ] ; then
        echo "$(tput setaf 3)Restore $(ls -l $restore_file | tr -s ' ' | cut -d ' ' -f 9,10,11)$(tput sgr 0)"
    elif ! [ -e $restore_file ] && ! [ -e $target ]; then
        echo "$(tput setaf 208)No Restore file for target $target.$(tput sgr 0)"
    elif [ -L $target ] ; then
        echo "$(tput setaf 208)Target $target exists but no Restore file.  Restore will delete it$(tput sgr 0)"
    fi

    if [ -e $target ] && [ -L $target ] ; then
        echo "$(tput setaf 4)Target $(ls -l $target | tr -s ' ' | cut -d ' ' -f 9,10,11)$(tput sgr 0)"
    elif [ -e $target ] ; then
        echo "$(tput setaf 1)Target $(ls -l $target | tr -s ' ' | cut -d ' ' -f 9,10,11) exists and is not a link$(tput sgr 0)"
    else
        echo "$(tput setaf 208)Target $target does not exist$(tput sgr 0)"
    fi

    if [ -e $my_file ] ; then
        echo "$(tput setaf 2)My File : $(ls -l $my_file | tr -s ' ' | cut -d ' ' -f 9,10,11)$(tput sgr 0)"
        true
    else
        echo "Myfile $my_file does not exist"
    fi
}

################################################################################
# Execution
################################################################################
this_dir=$PWD



error_restore(){
    echo "$cmd : ERROR : Cannot $1 because there are restore files present"
    echo "$cmd : ERROR : Check it out and run 'link-pwd forget' to clear restore files"
}

exists_restore_files()
{
    ls -a | grep '.\.restore' > /dev/null
}

##################### Action based on presence of token file ###################

action=status
link_file=Linkfile
while [[ $# -gt 0 ]]
do
    option="$1"
    optarg="$2"
    case $option in
        -f|--file)
            if [ -z $optarg ] ; then
                echo "ERROR --file optarg empty"
                exit 1
            fi
            link_file=$optarg
            shift
            ;;
        forget)
            rm -f *.restore .*.restore
            exit 0
            ;;
        unlink)
            if ! exists_restore_files ; then
                action=save_target
            else
                error_restore unlink
                action=status
            fi
            ;;
        link)
            if ! exists_restore_files ; then
                action=save_and_link
            else
                error_restore link
                action=status
            fi
            ;;
        restore)
            if exists_restore_files ; then
                echo "$cmd : No restore files present"
                action=status
            fi
            ;;
        *)
            echo "Unknown option or subcommand $option"
            action=status
            ;;
    esac
    shift
done

################## VALIDATION There must be a Linkfile #########################
link_file=$PWD/$(basename $link_file)
if ! [ -e $link_file ] ; then
    echo "$cmd : ERROR : No \$PWD/$(basename $link_file)"
    echo "Note that this tool wants you to be in the same directory as the linkfile even if you specify it on the command line"
    exit 1
fi

################## VALIDATION all source files must be links ###################
if [[ "$1" != status ]] ; then
    i=1
    while read col1 extra ; do
        if [[ "$col1" != \#* ]] ; then
            the_target=$(eval echo $col1)
            if [ -e $the_target ] && ! [ -L $the_target ] ; then
                echo "$cmd : ERROR : Linkfile line $i : the_target=$col1 exists and is not a link"
                errors=true
            fi
        fi
        i=$(($i + 1))
    done < Linkfile

    if [[ $errors == true ]] ; then
        exit
    fi
fi
if [ -e $Linkfile ] ; then
    ################# Iterateion on the lines of the file ##########################
    while read column_1 column_2 extra ; do

        if [[ "$column_1" = \#* ]] ; then
            continue
        fi

        the_target=$(eval echo $column_1)
        the_my_file=$this_dir/$(eval echo $column_2)

        ! [ -z $action ] && $action $the_target $the_my_file

    done < $link_file
    exit 0

elif ! [ -z "$linkfile" ] ; then
    exit 0
    if [[ $this_dir == $PWD ]] ; then
        for l in "${linkfile[@]}" ; do
            the_target=$(echo $l | tr -s ' ' | cut -d ' ' -f 1)
            the_my_file=$this_dir/$(echo $l | tr -s ' ' | cut -d ' ' -f 2)
            ! [ -z $action ] && $action $the_target $the_my_file
        done
    else
        echo "$0 : ERROR : The script needs to be called from the directory where it is to be used without a Linkfile"
        exit 1
    fi
else
    echo "$cmd : ERROR :No links array in script and no Linkfile in pwd"
fi


