#!/bin/bash
#

################################################################################
# Save is either saving a copy of the link or remembering that there was nothing
# there
################################################################################
save_src(){
    local src=$1
    local my_file=$2

    if ! [ -e $src ] ; then
        echo "$(tput setaf 5)REMEMBERING that there was no $src file by touching $(basename $src).delete$(tput sgr 0)"
        touch $(basename $src).delete
    else
        echo "$(tput setaf 2)SAVING $src as $(basename $src).restore$(tput sgr 0)"
        mv $src $(basename $src).restore
    fi
}
################################################################################
# Restore by either deleting or squashing with the saved file
################################################################################
restore_src(){
    local src=$1
    local base_src=$(basename $src)
    local restoration_file=$(find . -name "$base_src.restore" -o -name "$base_src.delete" | tail -1)

    if [ -z $restoration_file ] || ! [ -e $restoration_file ] ; then
        return 0
    fi

    if [[ $restoration_file == *restore ]] ; then
        echo "$(tput setaf 3)RESTORING $src from $restoration_file$(tput sgr 0)"
        # Note that the -T option doesn't work on OSX's mv command so I have to
        # remove the link first otherwise, it might move $restoration_file
        # into the directory pointed to by $src
        rm -f $src
        mv $restoration_file $src
    elif [[ $restoration_file == *delete ]] && [ -L $src ] ; then
        echo "$(tput setaf 1)DELETING link $src$(tput sgr 0)"
        rm -f $src
        rm $restoration_file
    fi
}

################################################################################
# Create a link for the file if the target exitst in pwd
################################################################################
maybe_link(){
    local target=$1
    local link_name=$2

    if [ -e $target ] ; then
       echo "$(tput setaf 4)LINKING $link_name --> $target$(tput sgr 0)"
       ln -s $target $link_name
    fi
}

################################################################################
# Execution
################################################################################
this_dir=$PWD

################## VALIDATION all source files must be links ###################
i=-1
while read col1 extra ; do
   i=$(($i + 1))
   if [[ "$col1" = \#* ]] ; then
      continue
   fi
   src=$(eval echo $col1)
   if [ -e $src ] && ! [ -L $src ] ; then
      echo "Precheck ERROR Linkfile line $i: $col1 exist and is not a link"
      errors=true
   fi
done < Linkfile

if [[ $errors == true ]] ; then
   exit
fi

##################### Action based on presence of token file ###################
action(){
   src=$1
   my_file=$2
   if [ -e ./ACTIVE ] ; then
      restore_src $src
   else
      save_src $src $my_file
      maybe_link $my_file $src
   fi
}

################# Iterateion on the lines of the file ##########################
while read column_1 column_2 extra ; do

   if [[ "$column_1" = \#* ]] ; then
      continue
   fi

   src=$(eval echo $column_1)
   my_file=$this_dir/$(eval echo $column_2)

   action $src $my_file

done < Linkfile

################## Toggle token file for next invocation #######################
if [ -e ./ACTIVE ] ; then
   rm ./ACTIVE
else
   touch ./ACTIVE
fi
