#!/bin/bash
#
# For each link in Linkfile:
#     base=$(basename link)
#     save links previous state
#     replace link with link to $PWD/base
#
# For each link in Linkfile:
#     restore link to previous state
#
# Note: The state of the link might be to not exist, this will still be saved
#       and restored
# Note: All files concerned must be links or the script will abort
# Note: The script alternates between linking and unlinking by leaving a file
#       called ACTIVE in the PWD
# Note: The states of links are saved by saving a copy as $PWD/$base.restore
#       or by creating a file called $PWD/$base.delete so you should no use
#       files with names ending with '.delete' or '.restore'
#

################################################################################
# Make the current directory's emacs files the active ones and save the
# emacs links.
################################################################################
takeover(){
   local src=$1
   local my_file=$2
   maybe_move $src $my_file
   maybe_link $my_file $src
}

################################################################################
# Restore from the saved emacs links in the current directory.
################################################################################
restore(){
    local src=$1

    for f in $files ; do
        maybe_restore $f
    done
}
################################################################################
# Save is either saving a copy of the link or remembering that there was nothing
# there
################################################################################
maybe_move(){
    local src=$1
    local my_file=$2

    if ! [ -e $src ] ; then
        echo "$(tput setaf 5)REMEMBERING that there was no $src file by touching $(basename $src).delete$(tput sgr 0)"
        touch $(basename $src).delete
    else
        echo "$(tput setaf 2)SAVING $src as $(basename $src).restore$(tput sgr 0)"
        mv $src $(basename $src).restore
    fi
}
################################################################################
# Restore by either deleting or squashing with the saved file
################################################################################
maybe_restore(){
    local src=$1
    local to_restore=$(basename $src)
    local restoration_file=$(find . -name "$to_restore.restore" -o -name "$to_restore.delete" | tail -1)

    if [ -z $restoration_file ] || ! [ -e $restoration_file ] ; then
        return 0
    fi

    if [[ $restoration_file == *restore ]] ; then
        echo "$(tput setaf 3)RESTORING $src from $restoration_file$(tput sgr 0)"
        mv $restoration_file $src
    elif [[ $restoration_file == *delete ]] ; then
        rm $restoration_file
        if [ -L $src ] ; then
            echo "$(tput setaf 1)DELETING link $src$(tput sgr 0)"
            rm -f $src
        fi
    fi
}

################################################################################
# Create a link for the file if the target exitst in pwd
################################################################################
maybe_link(){
    local target=$1
    local link_name=$2

    if [ -e $target ] ; then
       echo "$(tput setaf 4)LINKING $link_name --> $target$(tput sgr 0)"
       ln -s $target $link_name
    fi
}

################################################################################
# Execution
################################################################################

this_dir=$PWD
token=ACTIVE

while read column_1 column_2 extra ; do

   if [[ "$column_1" = \#* ]] ; then
      continue
   fi

   src=$(eval echo $column_1)
   my_file=$(eval echo $column_2)

   if [ -e $token ] ; then
      takeover $src $my_file
   else
      maybe_restore $src $my_file
   fi

done < Linkfile

if [ -e $token ] ; then
   rm $token
else
   touch $token
fi
