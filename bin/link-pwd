#!/bin/bash
#
# For each link in Linkfile:
#     base=$(basename link)
#     save links previous state
#     replace link with link to $PWD/base
#
# For each link in Linkfile:
#     restore link to previous state
#
# Note: The state of the link might be to not exist, this will still be saved
#       and restored
# Note: All files concerned must be links or the script will abort
# Note: The script alternates between linking and unlinking by leaving a file
#       called ACTIVE in the PWD
# Note: The states of links are saved by saving a copy as $PWD/$base.restore
#       or by creating a file called $PWD/$base.delete so you should no use
#       files with names ending with '.delete' or '.restore'
#

################################################################################
# Make the current directory's emacs files the active ones and save the
# emacs links.
################################################################################
takeover(){
    for f in $files ; do
        maybe_take $f
        maybe_link $f
    done
    touch $token
}

################################################################################
# Restore from the saved emacs links in the current directory.
################################################################################
restore(){
    for f in $files ; do
        maybe_restore $f
    done
    rm $token
}
################################################################################
# Save is either saving a copy of the link or remembering that there was nothing
# there
################################################################################
maybe_take(){
    local src=$1

    if ! [ -e $src ] ; then
        echo "$(tput setaf 5)REMEMBERING that there was no $src file by touching $(basename $src).delete$(tput sgr 0)"
        touch $(basename $src).delete
    else
        echo "$(tput setaf 2)SAVING $src as $(basename $src).restore$(tput sgr 0)"
        mv $src $(basename $src).restore
    fi
}
################################################################################
# Restore by either deleting or squashing with the saved file
################################################################################
maybe_restore(){
    local to_restore=$(basename $1)
    local restoration_file=$(find . -name "$to_restore.restore" -o -name "$to_restore.delete" | tail -1)
    local dst=$1

    if [ -z $restoration_file ] || ! [ -e $restoration_file ] ; then
        return 0
    fi

    if [[ $restoration_file == *restore ]] ; then
        echo "$(tput setaf 3)RESTORING $dst from $restoration_file$(tput sgr 0)"
        mv $restoration_file $dst
    elif [[ $restoration_file == *delete ]] ; then
        rm $restoration_file
        if [ -L $dst ] ; then
            echo "$(tput setaf 1)DELETING link $dst$(tput sgr 0)"
            rm -f $dst
        fi
    fi
}

################################################################################
# Create a link for the file if the target exitst in pwd
################################################################################
maybe_link(){
    local link_name=$1
    local base=$(basename $1)
    base=${base##.}
    local target=$this_dir/$base

    if [ -e $target ] ; then
       echo "$(tput setaf 4)LINKING $link_name --> $target$(tput sgr 0)"
       ln -s $target $link_name
    fi
}

################################################################################
# Execution
################################################################################

for f in $files ; do
    if [ -e $f ] && ! [ -L $f ] ; then
        echo "ERROR : file $f exists and is not a link"
        exit 1
    fi
done

for f in $(cat Linkfile) ; do
   files="$files $(eval echo $f)"
done

this_dir=$PWD
token=ACTIVE

if [ -e $token ] ; then
   restore
else
   takeover
fi
